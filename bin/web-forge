#!/usr/bin/env node

const createTempExtension = require('./handleExtensionFolder.js');
const { createServer, server } = require('./server.js');
const pathLib = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const { spawn } = require('child_process');
const { program } = require('commander');

const tempDirName = `temp_${uuidv4()}`;
const tempDirPath = pathLib.join(__dirname, tempDirName);

let browserProcess = null;

async function Webforge(browser, path, args) {
    const browserPath = getBrowserPath(browser);
    if (browserPath != null) {
        path = path || process.cwd()
        try {
            await createTempExtension(path, tempDirPath);
            createServer(path, tempDirPath);

            console.log(args);
            const launchOptions = [
                `--user-data-dir=${pathLib.join(tempDirPath, 'userFolder')}`,
                `--load-extension=${pathLib.join(tempDirPath, 'extension')}`,
                '--no-first-run',
                ...(args ? args.split(" ") : [])
            ];

            browserProcess = spawn(browserPath, launchOptions);

            browserProcess.on('close', (code) => {
              cleanUp(tempDirPath);
            });

        } catch (error) {
            console.log(error);
        }
    } else {
        console.error(`Was unable to find any valid browser paths for ${browser}`);
    }
}

// Returns an default path for browsers
function getBrowserPath(browser) {
    const browserDefaultPathMap = {
      "chrome": ["C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe", "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"],
      "msedge": ["C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe", "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"],
      "brave": ["C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe", "C:\\Program Files (x86)\\BraveSoftware\\Brave-Browser\\Application\\brave.exe"]
    };

    const paths = browserDefaultPathMap[browser.toLowerCase()] || [];

    for (const path of paths) {
        if (fs.existsSync(path)) {
            return path;
        }
    }

    return null;
}

async function cleanUp(tempDirPath) {
    if (browserProcess) {
        browserProcess.kill();
    }
    server.close();
    await removeTempDir(tempDirPath);
    process.exit(0);
}

process.on('SIGINT', async () => {
    if (programLock) {
        try {
            await cleanUp(tempDirPath);
          } catch (error) {
            console.error('Error during cleanup:', error);
            process.exit(1);
          }
    } else {
        process.exit(0);
    }
  });


async function removeTempDir(tempDirPath) {
        // Safe mechanism so that the path has to end with /web-forge/bin/temp_(random uuid) 
    const pattern = new RegExp(/\\web-forge\\bin\\temp_[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$/i);
    
    if (pattern.test(tempDirPath) && fs.existsSync(tempDirPath)) {
        // Have to have because the browser might be using userfolder for couple seconds still after shutting down which would cause permission issues.
        let attempts = 0;
        while (attempts < 10) {
            try {
                fs.rmSync(tempDirPath, { recursive: true });
                break;
            } catch (deleteError) {
                //console.error(`Error deleting ${tempDirPath}: ${deleteError}`);
            }
            attempts++;
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    } else {
        console.log('Invalid temp extension folder path or folder does not exist.', tempDirPath);
    }
}

function validateBrowser(browser) {
    const browserMappings = [
        ['chrome', 'ch'],
        ['edge', 'msedge'],
        ['brave', 'br']
    ];

    for (const mapping of browserMappings) {
        if (mapping.includes(browser)) {
            return mapping[0];
        }
    }

    console.error(`Received an unknown browser ${browser}`);
    return false;
}


let programLock = false;

// Maybe make it just so browser can be string too and maybe split it at , so like "chrome, edge" and it opens up chrome and edge. If you do this then just remove -a
program
  .option('-b, --browser <browser>', 'Launch specific browser. Accepts chrome/ch/edge/msedge/brave/br')
  .option('-a, --all-browsers', 'Launches all browsers. cant be used together with -b')
  .option('-p, --path <path>', 'Path to extension. Defaults to current folder if no path is given.')
  .option('-args, --arguments <args>', 'Extra arguments as a string')
  .option('-help, --help', 'Shows available arguments.')
  .parse(process.argv);


if (program.opts().browser && program.allBrowsers) {
  console.error('Cannot use both -b and -a options at the same time.');
  process.exit(1);
}

if (program.opts().help) {
    console.log('')
    console.log('Web-forge');
    console.log('   -b <browser>', '| Launch specific browser. Accepts chrome/ch/edge/msedge/brave/br')
    console.log('   -a', '          | Launches all browsers. cant be used together with -b')
    console.log('   -p <path>', '   | Path to extension. Defaults to current folder if no path is given.')
    console.log('   -args <args>', '| Extra arguments as a string')
    console.log('   -help', '       | Shows available arguments.')
    console.log('');
    console.log('Examples:');
    console.log('   web-forge -b chrome -args "--kiosk"');
    console.log('   web-forge -b edge -p "path/to/extension"');
    console.log('');
    process.exit(0);
} else {
    if (validateBrowser(program.opts().browser) !== false) {
        programLock = true;
        Webforge(program.opts().browser, program.opts().path, program.opts().arguments);
    } else {
        console.log('Invalid browser. Exiting...');
        process.exit(0);
    }
}