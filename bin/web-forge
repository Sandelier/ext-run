#!/usr/bin/env node

const createTempExtension = require('./handleExtensionFolder.js');
const { createServer, server } = require('./server.js');
const pathLib = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const { spawn } = require('child_process');
const { program } = require('commander');

const tempDirName = `temp_${uuidv4()}`;
const tempDirPath = pathLib.join(__dirname, tempDirName);

let browserProcesses = [];

async function Webforge(browser, path, args) {
    path = path || process.cwd()
    try {
        await createTempExtension(path, tempDirPath);
        createServer(path, tempDirPath);

        // Starts up browsers with arguments.
        for (const browserName of browser) {
            const browserPath = getBrowserPath(browserName);
            if (browserPath) {
                const launchOptions = [
                    `--user-data-dir=${pathLib.join(tempDirPath, 'userFolder', browserName)}`,
                    `--load-extension=${pathLib.join(tempDirPath, 'extension')}`,
                    '--no-first-run',
                    ...(args ? args.split(" ") : [])
                ];

                const browserProcess = spawn(browserPath, launchOptions);
                browserProcesses.push(browserProcess); 

                browserProcess.on('close', (code) => {
                    browserProcesses = browserProcesses.filter(process => process !== browserProcess);

                    if (browserProcesses.length === 0) {
                        cleanUp(tempDirPath);
                    }
                });
            } else {
                console.log(`Unable to find valid path for ${browserName}`);
                if (browserProcesses.size == 0) {
                    cleanUp(tempDirPath);
                }
            }
        }

    } catch (error) {
        console.log(error);
    }
}

// Returns an default path for browsers
function getBrowserPath(browser) {
    const browserDefaultPathMap = {
      "chrome": ["C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe", "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"],
      "msedge": ["C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe", "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"],
      "brave": ["C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe", "C:\\Program Files (x86)\\BraveSoftware\\Brave-Browser\\Application\\brave.exe"]
    };

    const paths = browserDefaultPathMap[browser.toLowerCase()] || [];

    for (const path of paths) {
        if (fs.existsSync(path)) {
            return path;
        }
    }

    return null;
}

async function cleanUp(tempDirPath) {
    for (const browser of browserProcesses) {
        browser.kill();
    }
    server.close();
    await removeTempDir(tempDirPath);
    process.exit(0);
}

process.on('SIGINT', async () => {
    if (programLock) {
        try {
            await cleanUp(tempDirPath);
          } catch (error) {
            console.error('Error during cleanup:', error);
            process.exit(1);
          }
    } else {
        process.exit(0);
    }
  });


async function removeTempDir(tempDirPath) {
        // Safe mechanism so that the path has to end with /web-forge/bin/temp_(random uuid) 
    const pattern = new RegExp(/\\web-forge\\bin\\temp_[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$/i);
    
    if (pattern.test(tempDirPath) && fs.existsSync(tempDirPath)) {
        // Have to have because the browser might be using userfolder for couple seconds still after shutting down which would cause permission issues.
        let attempts = 0;
        while (attempts < 10) {
            try {
                fs.rmSync(tempDirPath, { recursive: true });
                break;
            } catch (deleteError) {
                //console.error(`Error deleting ${tempDirPath}: ${deleteError}`);
            }
            attempts++;
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    } else {
        console.log('Invalid temp extension folder path or folder does not exist.', tempDirPath);
    }
}

// Returns valid browsers based on browser input and browsermapping.
function validateBrowser(browser) {
    const browserMappings = [
        ['chrome', 'ch'],
        ['edge', 'msedge'],
        ['brave', 'br']
    ];

    const uniqueBrowsers = new Set();

    const browserNames = browser.split(',');

    for (const inputBrowser of browserNames) {
        let foundMapping = false;
        for (const mapping of browserMappings) {
            if (mapping.includes(inputBrowser)) {
                uniqueBrowsers.add(mapping[0]);
                foundMapping = true;
                break;
            }
        }
        if (!foundMapping) {
            console.error(`Received an unknown browser ${inputBrowser}`);
        }
    }

    if (uniqueBrowsers.size === 0) {
        console.error('No valid browsers found. Exiting...');
        return false;
    }

    return Array.from(uniqueBrowsers);
}


let programLock = false;

program
  .option('-b, --browser <browser>', 'Launch specific browser. Accepts chrome/ch/edge/msedge/brave/br. You can also put browsers into string to launch multiple -b "chrome,edge".')
  .option('-p, --path <path>', 'Path to extension. Defaults to current folder if no path is given.')
  .option('-args, --arguments <args>', 'Extra arguments as a string')
  .option('-help, --help', 'Shows available arguments.')
  .parse(process.argv);


if (program.opts().help) {
    console.log('')
    console.log('Web-forge');
    console.log('   -b <browser>', '| Launch specific browser. Accepts chrome/ch/edge/msedge/brave/br You can also put browsers into string to launch multiple -b "chrome,edge".')
    console.log('   -p <path>', '   | Path to extension. Defaults to current folder if no path is given.')
    console.log('   -args <args>', '| Extra arguments as a string')
    console.log('   -help', '       | Shows available arguments.')
    console.log('');
    console.log('Examples:');
    console.log('   web-forge -b chrome -args "--kiosk"');
    console.log('   web-forge -b edge -p "path/to/extension"');
    console.log('');
    process.exit(0);
} else {
    const validBrowser = validateBrowser(program.opts().browser);
    if (validBrowser !== false) {
        programLock = true;
        Webforge(validBrowser, program.opts().path, program.opts().arguments);
    } else {
        process.exit(0);
    }
}