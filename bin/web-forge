#!/usr/bin/env node

const createTempExtension = require('./handleExtensionFolder.js');
const { createServer, server, eventEmitter } = require('./server.js');
const pathLib = require('path');
const { exec } = require('child_process');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const { error } = require('console');


const tempDirName = `temp_${uuidv4()}`;
const tempDirPath = pathLib.join(__dirname, tempDirName);

let browserProcess = null;

async function Webforge(browser, path, args) {

    const launchArgs = `start ${browser} --user-data-dir=${pathLib.join(tempDirPath, 'userFolder')} --load-extension=${pathLib.join(tempDirPath, 'extension')} --no-first-run ${args}`;
    path = path || process.cwd()
    try {
        await createTempExtension(path, tempDirPath);
        createServer(path);

        eventEmitter.on('socketClosed', () => {
            cleanUp(tempDirPath);
        });

        /*  Need to think of an better way to do this since i tried using spawn childprocess but didint work since the browsers arent always in environment variables.
            And why this is bad because i cant detect when the browser closes so the program dosent have any idea when to close itself.
            And same thing int he websocket that its not good to clsoe it immediately if client disconnects because 
            what if the user just closes the extension and puts it back on since that causes an disconnect too. */
            
        browserProcess = exec(launchArgs, (error, stdout, stderr) => {
            if (error) {
                console.error(`Error: ${error.message}`);
                return;
            }
            if (stderr) {
                console.error(`stderr: ${stderr}`);
                return;
            }
        });

    } catch (error) {
        console.log(error);
    }
}

async function cleanUp(tempDirPath) {
    if (browserProcess) {
        browserProcess.kill();
    }
    server.close();
    await removeTempDir(tempDirPath);
    process.exit(0);
}

// Have to have because the browser might be using userfolder for couple seconds still after shutting down which would cause permission issues.
async function waitForUnlockAndDelete(filePath) {
    let attempts = 0;
    let ErrorMessage = "";
    let interval = 1000
    while (attempts < 10) {
        try {
            fs.rmSync(filePath, { recursive: true });
            return;
        } catch (deleteError) {
            ErrorMessage = `Error deleting ${filePath}:`, deleteError;
        }
        await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    console.error(`Temp folder in ${filePath} could not be deleted after ${maxAttempts} attempts.`);
    console.error(ErrorMessage);
    return;
}

async function removeTempDir(tempDirPath) {
    // Safe mechanism so that the path has to end with /web-forge/bin/temp_(random uuid) 
    const pattern = new RegExp(/\\web-forge\\bin\\temp_[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$/i);
    
    if (pattern.test(tempDirPath) && fs.existsSync(tempDirPath)) {
        await waitForUnlockAndDelete(tempDirPath);
        console.log("done");
    } else {
        console.log('Invalid temp extension folder path or folder does not exist.', tempDirPath);
    }
}


function validateBrowser(browser) {
    const browserMappings = [
        ['chrome', 'ch'],
        ['edge', 'msedge'],
        ['brave', 'br']
    ];

    for (const mapping of browserMappings) {
        if (mapping.includes(browser)) {
            return mapping[0];
        }
    }

    return false;
}


const [, , method, browser , path, ...optionalArgs] = process.argv;

if (method !== undefined) {
    switch (method) {
        case "-b":
            // In the workings
            break;

        case "-r":
            if (validateBrowser(browser) !== false) {
                Webforge(browser, path, optionalArgs);
            } else {
                console.error(`Unknown browser: ${browser}`);
                process.exit(1);
            }
            break;

        default:
            console.error(`Unknown method: ${method}`);
            break;
    }
} else {
    console.log('Usage: web-forge <-b|-r> <path> <optional arguments>');
}